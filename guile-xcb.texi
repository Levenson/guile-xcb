\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename guile-xcb.info
@settitle The Guile XCB Manual 1.0
@c %**end of header

@copying
This manual is for Guile XCB, version 1.0.

Copyright @copyright{} 2013 Mark Witmer.

@quotation
   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."
@end quotation
@end copying

@dircategory The Algorithmic Language Scheme
@direntry
* Guile XCB: (guile-xcb).    An X11 Client for Guile
@end direntry

@titlepage
@title Guile XCB
@subtitle An X11 Client for Guile
@author Mark Witmer

@c  The following two commands
@c  start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying

@end titlepage

@c So the toc is printed at the start.
@contents

@ifnottex
@node Top
@top Guile XCB

This manual is for Guile XCB, version 1.0.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License."

Guile XCB is a Guile Scheme implementation of the XML-XCB project,
providing bindings for the core X11 protocol and many of its
extensions.

@end ifnottex

@menu
* Introduction::
* The XCB Data Structures::
* Interacting With the X Server::
* Writing Guile XCB Applications::

* Function Index::

@end menu

@findex

@node Introduction
@chapter Introduction

This chapter provides some background on the basic components used by
Guile XCB.

@menu
* The X Window System::           The foundation of GUIs for Unix and friends
* XCB::                           The X protocol C-language Binding
* Guile::                         GNU's Ubiquitous Intelligent Language for Extenions
* What to Import::                Where to find Guile XCB's procedures

@end menu

@node The X Window System
@section The X Window System

The @uref{http://www.opengroup.org/tech/desktop/x, X Window System, X
Window System} is a feature of many unix-like operating systems that
provides a mechanism for creating and interacting with graphical user
interfaces.

X is designed with a client-server architecture, in which an X server
listens for input from peripherals like the mouse and keyboard, and
draws graphical elements in windows on the screen. Client applications
can connect to the X server and send requests to query and modify
information about the windows managed by the server. They may also
select user input events and ask to be notified when they occur.

The server and client communicate using the X Protocol, a binary data
transfer format that defines a few basic types of messages or
packets. These include the following:

@itemize @minus
@item
Request: A message sent from the client to the server, either with the
purpose of manipulating data on the server side, or to query
information already present.

@item
Reply: A message sent from the server to the client that contains the
response to a previous request.

@item
Event: A message sent from the server to the client containing
information about a user input or other kind of action for which the
client has requested notification.

@item
Error: A message sent from the server to the client containing
information about an error---normally as a result of a faulty request
sent by the client.
@end itemize

Any application that can properly communicate with an X server using
this protocol can be considered an X client. Likewise, any application
that correctly handles communication with X clients is a valid X
server, although one would expect it to actually draw the windows
requested by the client and recognize and send user input events as
they happen. Additionally, the core X protocol has been joined over
time by a number of extensions, which specify additional behavior and
cabilities for X servers using the same basic transport.

For many years, the typical method for developing an X client involved
using the venerable
@uref{http://www.x.org/releases/X11R7.6/doc/@/libX11/specs/libX11/libX11.html,
Xlib} C library. Xlib does not allow direct access to the X
protocol. Instead, it attempts to provide a more user-friendly
interface on top of it. Xlib also frequently wraps asynchronous server
calls in synchronized code and does not easily accomodate using X
extensions. More shortcoming of using Xlib are amply described
@uref{http://xcb.freedesktop.org/Features, elsewhere}.

@node XCB
@section XCB

To address some of the limitations of Xlib, some developers created
@uref{http://xcb.freedesktop.org/, XCB, XCB} (X protocol C-language
Binding), a lower-level library the directly maps to the X protcol. In
order to do this, they created a set of XML files that thoroughly
describe the X protocol and many of its extensions. A python script
generates C code based on the XML files for sending X requests and
processing replies, events, and errors asynchronously.

The X protocol XML files are of primary interest in this project; they
provide a language-agnostic description of the X protocol that can be
used to generate bindings in a variety of languages.

@node Guile
@section Guile

@uref{http://www.gnu.org/software/guile, Guile} (GNU's
Ubiquitous Intelligent Language for Extensions), is an implementation
of the Scheme programming language with accompanying compiler and
virtual machine. Guile can serve as a standalone environment for
application development or it can be integrated with C/C++
applications as an extension language.

In Guile, Scheme sits on top of a ``compiler tower'' of languages that
ends with compiled virtual machine bytecode. It is possible to
implement a new language in Guile by writing a compiler that
translates the new language into one of the built-in languages.

Guile XCB uses this facility to compile the X protocol XML files into
Scheme code. Once compiled, the core protocol and available extensions
are each represented by a Guile module.

@node What to Import
@section What to Import

The core X protocol is defined in module @code{(xcb xml
xproto)}. Support functions for interacting with the X server are
found in @code{(xcb xml)}, and functions for running an event loop are
in @code{(xcb event-loop)}. @xref{The Event Loop}.

Extensions to the X protocol are found in modules named using the
format @code{(xcb xml ext @var{extension-name})}. @xref{Using
Extensions}. @var{extension-name} can be one of the following:

@code{bigreq}, @code{composite}, @code{damage}, @code{dpms},
@code{dri2}, @code{ge}, @code{glx}, @code{randr}, @code{record},
@code{render}, @code{res}, @code{screensaver}, @code{shape},
@code{shm}, @code{sync}, @code{xc_misc}, @code{xevie}, @code{xf86dri},
@code{xf86vidmode}, @code{xfixes}, @code{xinerama}, @code{xinput},
@code{xkb}, @code{xselinux}, @code{xtest}, @code{xv}, or @code{xvmc}.

Some of these extensions, while supported by Guile XCB, are deprecated
and may not be available with the latest X server versions.

@node The XCB Data Structures
@chapter The XCB Data Structures

Guile XCB compiles the XML specification of the X protocol into a
variety of Scheme record types, procedures, and values.

@menu

* Structures::         XCB Structures in Scheme
* Types::              Sending valid data to the X Server
* Enums and Masks::    How Guile XCB handles C enums

@end menu

@node Structures
@section Structures

Since the original purpose of XCB was to create a C interface based on
the X protocol XML files, the schema of the XML files coincides nicely
with C structures.

Guile XCB defines objects that behave similarly to C structures, and
provides the means for accessing and modifying their values.  For
example, when the following XML from xproto.xml is compiled, the new
module will contain a variable named @code{SetupFailed}:

@example

<struct name="SetupFailed">
  <field type="CARD8" name="status" /> <!-- always 0 -> Failed -->
  <field type="CARD8" name="reason_len" />
  <field type="CARD16" name="protocol_major_version" />
  <field type="CARD16" name="protocol_minor_version" />
  <field type="CARD16" name="length" />
  <list type="char" name="reason">
    <fieldref>reason_len</fieldref>
  </list>
</struct>

@end example

@code{SetupFailed} is a Scheme object the keeps track of information
about SetupFailed structures received from the X server, including
their fields and how they are read and written. An instance of
@code{SetupFailed} can be created with the procedure
@code{make-SetupFailed}, which takes as arguments values for each of
the fields described above. The last field, a list with name
@code{reason}, is represented as a vector. @footnote{Unfortunately,
because of XCB's C orientation, it is necessary to provide a value for
@samp{reason_len} even though the length of the vector given for
@samp{reason} is already evident.}

@deffn {Scheme Procedure} make-SetupFailed status reason_len protocol_major_version protocol_minor_version length reason
Create an xcb struct of type SetupFailed
@end deffn

Fields of an xcb structure instance can be accessed using the
procedure @code{xref}.

@deffn {Scheme Procedure} xref rec field | rec field n
Return the value of field @var{field} in record @var{rec}. In the
second form, return the @var{n}th value of list field @var{field} in
record @var{rec}.
@end deffn

Fields of an xcb structure instance can be modified using the
procedure @code{xset!}.

@deffn {Scheme Procedure} xset! rec field val | rec field n val
Set the value of field @var{field} in @var{rec} to @var{val}. In the
second form, set the @var{n}th element of list field @var{field} in
@var{rec} to @var{val}.
@end deffn

Guile XCB will check to ensure that each value conforms to its type
before sending the record to the X server and will cause an error if
any do not. @xref{Types}. Some fields require that a value belong to a
specific enum or mask; their values are specified with symbols rather
than integer values. @xref{Enums and Masks}.

@node Types
@section Types

Since the X protocol is a binary format, an exact number of bytes must
be used to transfer each field of a structure to the X
server. Likewise, the client must know exactly how many bytes to read
for each field of data received from the server. For this reason, the
XML files specify a type for each field in every xcb structure.

Guile XCB associates each type with a predicate to test if a value
belongs to the type, procedures for reading and writing values to/from
a binary port, and optionally an enum or mask containing a list of
possible values. @xref{Enums and Masks}. Some types are opaque to the
user, meaning that the values they contain are only of practical use
for the server and should remain ``boxed'' when handled by a client.

To see what types are required in a structure, evalate the name of
the structure at the REPL and the record type printer will display its
field names and types.

@menu
* Core Types::
* Derived Types::
@end menu

@node Core Types
@subsection Core Types

Some types are available to all X extensions. For these types, the
user should provide values with the properties described below:

@itemize @minus
@item
CARD8: An unsigned one-byte integer
@item
CARD16: An unsigned two-byte integer
@item
CARD32: An unsigned four-byte integer
@item
BYTE: Same as CARD8; sometimes used in lists for strings
@item
INT8: A signed one-byte integer
@item
INT16: A signed two-byte integer
@item
INT32: A signed four-byte integer
@item
char: A Scheme character in the Latin-1 range (0-255)
@item
void: Same as CARD8, usually used in blobs of binary data
@item
BOOL: @code{#t} or @code{#f}
@end itemize

@node Derived Types
@subsection Derived Types

Each X extension can define more types of its own by combining or
renaming core types in various ways. These include the following:

@itemize @minus
@item
typedef: This is a simple alias for a type. The newly defined type has
all of the same properties as the original.
@item
xidtype: These are 4-byte opaque types representing handles to objects
managed by the X server. XIDs are created with the procedure
@code{make-new-xid}. @xref{XIDs}.
@item
struct: Each struct also has a type associated with it (identified by
the variable @var{structname}-type) and can be included as the type of a
field in other structs.
@item
union: These types refer to a list of fields much like structures
do. However, the union only contains one value. When the user requests
the value of one of the fields, that single value is converted from
raw bytes to the appropriate field's representation.

@deffn {Scheme Procedure} xunion-ref rec field
Return the data in xcb union instance @var{rec} represented as a value
conforming to the specification of @var{field}.
@end deffn
@end itemize

@node Enums and Masks
@section Enums and Masks

Some fields also have an additional property that affects the type of
values they contain. These are @samp{enum}, @samp{mask}, and
@samp{altenum}.

For @samp{enum} fields, rather than providing a number, the user
should provide the symbol that is the name of a value in the specified
enum.  For example, if a field is limited to the enum
@code{BackingStore}, the user must provide one of the following
symbols as a value: @code{NotUseful}, @code{WhenMapped}, or
@code{Always}. Guile XCB will not accept integer values for this
value.

@samp{mask} fields use a list of symbols, each one representing a
value from the mask, which are then combined with @code{logior}.

@samp{altenum} fields are like @samp{enum} fields, except that they
accept any integer value within the provided type as well as any
symbol from among the enum keys.

When accessed, values in structs that are associated with enums will
likewise be represented as symbols or lists of symbols. If a value
with a type referencing an altenum is not listed in the enum, the raw
numeric value will be provided instead.

To determine what symbols are present in an enum, consult the XML file
or evalute the name of the enum at the REPL. Clients may also access
the underlying numeric values in a enum with the procedure
@code{xenum-ref}.

@deffn {Scheme Procedure} xenum-ref enum key
Returns the numeric value stored in @var{enum} with key @var{key}.
@end deffn

For fields that are not explicitly marked as using a mask but
nevertheless require values logior'd together, the procedure
@code{xenum-or} is available:

@deffn {Scheme Procedure} xenum-or enum . keys
Return the values associated with @var{keys} in xcb enum @var{enum}
combined with @code{logior}.
@end deffn

@deffn {Scheme Procedure} xenum-keys enum
Return a list of all the keys in the enum.
@end deffn

@deffn {Scheme Procedure} xenum-values enum
Return a list of all the values in the enum.
@end deffn

@node Interacting With the X Server
@chapter Interacting With the X Server

Using the previously described structures as a basis, Guile XCB
provides a simple interface for sending requests to the X server and
receiving replies, errors, and events. Procedures for interacting
with an X server are exported from the module (xcb xml).

@menu
* Connecting::         Connecting to the X Server
* Sending Requests::   Putting the X Server to work
* Replies and Errors::  Getting data back from the X Server
* Events::  Dealing with input from the outside
* Using Extensions::   Going beyond the core X protocol

@end menu

@node Connecting
@section Connecting to the X Server

Connections to the X service are created using the procedure
@code{xcb-connect!}.

@deffn {Scheme Procedure} xcb-connect! [display=(getenv ``DISPLAY'')] [hostname=(gethostname)]
Connect to the X server running on @var{display} and
@var{hostname}. Returns a record of type @code{xcb-connection}, which
is used for further interaction with the X server.
@end deffn

@var{display} should be in the format @samp{:n.p} or simply @samp{:n},
where @var{n} is the display number and @var{p} is a screen number.
When an X server is running, the variable @var{DISPLAY} with the
needed string as its value should be defined in the shell enivronment,
and that value is used by default.

@deffn {Scheme Procedure} xcb-disconnect! xcb-conn
Close the connection to the X server represented by @var{xcb-conn}
@end deffn

@deffn {Scheme Procedure} xcb-connected? xcb-conn
Returns @code{#t} if the xcb-connection has successfully connected to an X
server and contains a Setup value, otherwise returns @code{#f}
@end deffn

@deffn {Scheme Procedure} xcb-connection-setup xcb-conn
If @var{xcb-conn} is connected, returns the setup information provided
by the X server. Returns @code{#f} otherwise.
@end deffn

The setup information is stored in a struct of type @samp{Setup},
which is defined in the core X protocol XML file, xproto.xml.

@deffn {Scheme Procedure} xcb-connection-display xcb-conn
Returns the display string used to connect @var{xcb-conn}.
@end deffn

@node Sending Requests
@section Sending Requests

Each request defined in the X protocol and its available extensions
is represented by a Scheme procedure of the same name, with arguments
corresponding to the required fields. Some requests also include
optional fields. Their presence is determined by the value of one or
more other fields in the request.

@menu
* A Simple Request Example::
* Valueparams::
* Switches::
* XIDs::
* Predefined Values and Helpers::

@end menu

@node A Simple Request Example
@subsection A Simple Request Example

Perhaps sending requests to the X server is best illustrated with an
example from the core X protocol:

@deffn {Scheme Procedure} QueryExtension xcb-conn name_len name
Send a QueryExtension request to the X server connected to
@var{xcb-conn} with fields @var{name_len} and @var{name}. Returns
the sequence number of the request.
@end deffn

Sending a request to the server does not immediately result in a
reply. The user must poll the xcb connection for data until the
reply becomes available. @xref{Replies and Errors}.

@node Valueparams
@subsection Valueparams

A common method of specifying optional variables in an X request
involves two fields: a value mask, and a value list. Collectively they
are referred to as a valueparam. For every bit set in the value mask,
the X server will read off an element from the value list.

In the C implementation of XCB, the user has to combine values from an
enum using @code{|} in order to generate the value mask, and then
create a list of values in the correct order to match the bits in the
mask.

The Guile XCB approach is less complicated; in place of a value param,
the first argument is the name of the XCB enum that the value mask
corresponds to. The second argument is an associative list. The car of
each pair is the name of a value in the enum, and the cdr is the value
that goes with it. Guile XCB will create the value mask and value
param based on these arguments and ensure that the values are in the
correct order. @footnote{Guile XCB's valueparams do have one drawback:
only one valueparam is permitted per request, and none are permitted in
replies. This limitation eliminates support for the XPRINT extension,
which is deprecated and shouldn't be used anyway. Future versions of
Guile XCB may remove this restriction.}

The following example demonstrates the use of a valueparam to set a
window's location:

@lisp
(ConfigureWindow xcb-conn window
  ConfigWindow
  `((X . 100)
    (Y . 100)))
@end lisp

In this example, @code{ConfigWindow} is the name of the enum used in
the value mask, and @code{X} and @code{Y} are the values included in
the request.

All values in a valueparam have the same type (usually CARD32) whether
they are restricted to a certain enum or not. This makes it
impractical for Guile XCB to translate enum keys into numeric values
automatically as it normally would. Instead, a program should convert
the values manaully using @code{xenum-ref} and @code{xenum-or}.

@node Switches
@subsection Switches

In some X requests and replies, more than one value is considered when
determining which optional fields should be included. Valueparams are
insufficient in such cases, so the XCB developers created a more
generalized construct called a `switch,' due to its use of
@code{switch} syntax in the C implementation.

Switches can be present in both requests and replies, adding one
additional field to a xcb structure's record type. This field is an
associative list, where each pair has the name of a conditionally
included field as its car and the corresponding value as its
cdr. Consult the appropriate X extension specification to determine
which fields are expected under which circumstances.

The following example demonstrates the use of a switch in an XKEYBOARD
request:

@lisp
(SelectEvents conn 12
                '(NewKeyboardNotify)
                '(StateNotify)
                '(StateNotify)
                '(KeyActions)
                '(KeyActions)
                '((affectNewKeyboard . (Keycodes))
                  (newKeyboardDetails . (Geometry))))
@end lisp

At present, XKEYBOARD is the only extension which uses switches.

@node XIDs
@subsection XIDs

Some requests involve asking the X server to create and manage new
resources. These resources are referred to with unique identifiers
called ``XIDs.'' The client must create the new XIDs that it sends to
the server.

@deffn {Scheme Procedure} make-new-xid xcb-conn xcb-type
Generate a new unique identifier for referring to a resource
maintained by the X server connected to @var{xcb-conn}. X requests
that instruct the server to create, for example, new Windows or
Graphical Contexts require an XID for the new resource. @var{xcb-type}
is an xid type such as @code{WINDOW} or @code{GC}.
@end deffn

Sometimes, due to ommissions in the XCB-XML files, replies from the X
server will store an XID's integer value without the annotation that
it is an XID. In this case, it might be necessary to convert the raw
integer into a typed XID.

@deffn {Scheme Procedure} make-xid n xid-type
Create an XID with of type @var{xid-type} with id number @var{n}.
@end deffn

On other occasions, it can be useful to extract the integer value from
an XID.

@deffn {Scheme Procedure} xid->integer xid
Return the raw integer value of @var{xid}.
@end deffn

It can also be useful to compare XIDs:

@deffn {Scheme Procedure} xid= xid1 xid2
Returns @code{#t} if the integer value and type of @var{xid1} and
@var{xid2} are the same (@code{=} and @code{eq?}, respectively).
@end deffn

Applications that require more XIDs than are initially available may
enable and use the XC_MISC X extension when available. @xref{X
Extensions Used by Guile XCB}.

@node Predefined Values and Helpers
@subsection Predefined Values and Helpers

Because the X protocol is a binary protocol and everything must be
expressed numerically, managing complex values and even strings can be
unwieldy. Guile XCB provides a few procedures and values to simply
these tasks.

@deffn {Scheme Variable} xcb-current-time
Alias for the value zero to use in fields that describe X timestamps;
causes the X server to use the current time for the field's value.
@end deffn

@deffn {Scheme Procedure} xcb-none xid-type
Create an XID for @var{xid-type} with an actual value of zero; for use in
fields of X requests that accept ``none'' as an option instead of a
defined XID.
@end deffn

@deffn {Scheme Procedure} string->xcb str
Convert a Latin-1 string into a vector of xcb chars.
@end deffn

@deffn {Scheme Procedure} xcb->string
Convert a vector of xcb chars into a Latin-1 string.
@end deffn

@deffn {Scheme Procedure} xcb-bytes->string
Convert a vector of xcb bytes into a Latin-1 string.
@end deffn

@deffn {Scheme Procedure} string->xcb2b
Convert a string of C widechars into a vector of xcb double-width
chars.
@end deffn

@deffn {Scheme Procedure} xcb-event->vector xcb-conn event

Convert @var{event} into a character vector for use in sending a
@code{SendEvent} request on connection @var{xcb-conn}.

@end deffn

@node Replies and Errors
@section Replies and Errors

Many X requests elicit replies from the X server. Because the X
protocol is asynchronous, the client must check its connection with
the server periodically to see if any replies, errors, or events
have arrived.

@deffn {Scheme Procedure} poll-xcb-connection xcb-conn [async?=@code{#f}]
Receive the next reply, error, or event from the X server connected to
@var{xcb-conn}. If @var{async?} is @code{#t}, the procedure will
return the values @code{'none} and @code{#f} if no data is immediately
available. Otherwise the procedure will block for a response.

This procedure returns two values---the first is a symbol
(@code{reply}, @code{error}, or @code{event}) indicating the type of
structure received from the server. The second value is a vector
containing the data received from the server. The vector can be
referenced directly or through the procedures @code{xcb-struct},
@code{xcb-data}, and @code{xcb-sequence-number}.
@end deffn

@deffn {Scheme Procedure} xcb-struct data
Returns the XCB struct (i.e. @code{KeyPress-event},
@code{QueryExtension-reply}, etc.) type for a piece of data sent by
the X server.
@end deffn

@deffn {Scheme Procedure} xcb-data data
Returns the instance of an XCB struct for a piece of data sent by the
X server.
@end deffn

@deffn {Scheme Procedure} xcb-sequence-number data
Returns the sequence number for a piece of data sent by the X
server. Note that this field is not present for events; if they have a
sequence number, it is included as one of the fields of the XCB struct
itself.
@end deffn

A reply from the X server is another xcb struct, this time with a name
in the form @code{@var{request-name}-reply}, such as
@code{QueryExtension-reply} or @code{GetWindowAttributes-reply}.

When something goes wrong while the X server processes a request,
either because of faulty data provided by the client or an internal
error, the X server may send an error message in place of a reply.
Errors have names in the form @code{@var{error-name}-error}, such as
@code{Alloc-error} and @code{Value-error}.

Calling an X request function returns a sequence number, which can be
stored and matched to the @code{xcb-sequence-number} field of a
subsequent call to @code{poll-xcb-connection}.

Using @code{poll-xcb-connection} directly can be
cumbersome. @pxref{The Event Loop} for a more convenient abstraction.

@node Events
@section Events

Like replies and errors, events from the X server are received as a
result of calls to @code{poll-xcb-connection}. They are represented
with XCB structures just like requests, replies, and errors. Their
names are in the form @code{@var{event-name}-event}, such as
@code{KeyPress-event} or @code{FocusIn-event}. @pxref{The Event Loop}
for an asynchronous means of handling events.

@node Using Extensions
@section Using Extensions

The core X protocol has been joined over time by a number of
extensions, which provide much of the actual functionality required by
modern X applications. Many of these extensions are available in Guile
XCB. @xref{What to Import}. Some are used by the Guile XCB code
itself, and the rest can be enabled as necessary.

@menu
* Enabling X Extensions::
* X Extensions Used by Guile XCB::
@end menu

@node Enabling X Extensions
@subsection Enabling X Extensions

If the X server includes an extension to the core protocol, the client
may make use of it by calling a procedure defined in the extension's
module.

@deffn{Scheme Procedures} xcb-enable-@var{extension-name}! xcb-conn [proc=@code{#f}]

Lazily enable the X extension with name @var{extension-name} for the X
connection connected to @var{xcb-conn}. If @var{proc} is a
procedure, call @var{proc} with the QueryExtension reply once it has
been received.

Returns an xcb tag as used by the optional event loop library, which
when solicited, returns @code{#t} or the result of @var{proc} (when
provided) if the extension is available, and @code{#f}
otherwise. @xref{Solicit and Notify}.

Extension names correspond to the value of the @code{header} attribute
in the root node of an X protocol XML file. Specific procedures of
this type are named @code{xcb-enable-bigreq!},
@code{xcb-enable-xc_misc!}, and so on.
@end deffn

A client can check to see if extensions have been enabled for a given
xcb connection.

@deffn {Scheme Procedure} xcb-connection-has-extension? xcb-conn ext-name
Return @code{#t} if an op code has been received from the X server
connected to @var{xcb-conn} for extension with name
@var{ext-name}. @var{ext-name} should be a symbol corresponding to the
value of the @code{header} attribute in the extension's XML file.
@end deffn

Note that Guile XCB does not perform any version negotiation with the
server; enabling an extension simply provides the xcb connection with
the opcode, first event number, and first error number necessary for
further interaction with the extension.

Most X extensions will export some bindings that conflict with those
exported by other X extensions. Modules that import extensions with
conflicting definitions should use @code{#:rename} as
appropriate. @inforef{Using Guile Modules, Using Guile Modules,
guile}.

@node X Extensions Used by Guile XCB
@subsection X Extensions Used by Guile XCB

Guile XCB can make use of three X extensions internally to provide a
more flexible client library to its users. These extensions are not
enabled by default but can be enabled by a program if their use is
required.

@itemize
@item
BIG-REQUESTS: In the core X protocol, requests are limited in size to
around 260KB. To support certain extensions that require longer
requests, the big requests extension was created to allow requests up
to 16GB. Guile XCB will automatically use big requests when necessary
if they are available.

@deffn {Scheme Procedure} enable-big-requests! xcb-conn enable
Modifies an xcb connection so that it can send requests larger than
the original limit using the big requests extension. @var{xcb-conn} is
the connection to modify and @var{enable} is the reply from a call to
the big request extension's @code{Enable} request.
@end deffn

@item
XC_MISC: The X server supports a limited number of XIDs per
connection; if the supply of XIDs runs out, @code{make-new-xid} will
abort to a continuable prompt where the user has the option of
retrieving a new range of XIDs from the server and updating the
connection as follows:

@lisp
(call-with-prompt
 out-of-xids
 (lambda () (make X requests here) ... )
 (lambda (return-next-xid xcb-conn)
   (parameterize ((current-xcb-connection xcb-conn))
     (let ((result (reply-for GetXIDRange)))
       (return-next-xid (update-xid-range! xcb-conn result))))))
@end lisp

This example uses @code{current-xcb-connection} and @code{reply-for}
from the optional event loop library; a program could obtain the
GetXIDRange reply from the server in some other manner as well.

@deffn {Scheme Procedure} update-xid-range! xcb-conn range
Modifies xcb connection @var{xcb-conn} to use the new xid range
provided by @var{range}, which should be the reply to an XC_MISC
@code{GetXIDRange} request. Returns the first xid in the new range.
@end deffn

@deffn {Scheme Variable} out-of-xids
The prompt tag Guile XCB will abort to when it runs out of XIDs for a
given connection. The abort handler accepts two variables;
@var{return-next-xid}, which should be called with the next XID the
connection can use, and @var{xcb-conn}, the XCB connection that has
run out of XIDs.
@end deffn

The use of a prompt in this occasion is to allow the user maximum
flexibility in handling XID exhaustion when necessary. Applications
that do not use enough XIDs to run out do not need to set up an
@code{ouf-of-xids} prompt.

@item
Generic Event Extension: Standard X events are limited to 32 bytes in
length and there are also a limited quantity of error opcodes
available. To circumvent both of these limitations, the Generic Event
Extension turns the event with opcode 35 into a special generic event,
which receives a standard header describing the contents of more
specific events, which can be longer than the original 32-byte limit.
If the extension is enabled, Guile XCB can handle generic events,
although they are only output by a small subset of the available
extensions.
@end itemize

@node Writing Guile XCB Applications
@chapter Writing Guile XCB Applications

The previously defined procedures for sending and receiving X data are
all one needs to write X applications. However, polling the connection
and handling replies, errors, and events manually can be distracting
and cumbersome. Guile XCB provides a basic framework for running an
event loop and describing in advance how data from the X server will
be handled.

@menu
* The Event Loop::
* Built-in XCB Documentation::
@end menu

@node The Event Loop
@section The Event Loop

There are no strict requirements regarding the format of an X
application, and Guile XCB does not impose any on its users. However,
one very common design is to run a loop that constantly polls the X
connection for events, errors, and replies and sends requests to
update the X server state depending on the data it receives.

One implementation of an event loop and several asynchronous X request
functions to go along with it are found in the @code{(xcb event-loop)}
module. @xref{What to Import}.

@menu
* Starting an Event Loop::
* Listening to the X Server::
* Solicit and Notify::
@end menu

@node Starting an Event Loop
@subsection Starting an Event Loop

The procedure @code{xcb-event-loop} provides a framework for running
an asynchronous event loop.

@deffn {Scheme Procedure} xcb-event-loop xcb-conn [proc]
Repeatedly poll the X server connected to @var{xcb-conn} for replies,
events, and errors, calling any handlers that might be associated with
them.

@var{proc} is a procedure that is run inside the event loop. Inside of
@var{proc}'s dynamic scope, the parameter
@code{current-xcb-connection} is bound to @var{xcb-conn}, and the
@code{solicit}/@code{notify} co-routines are also
available. @xref{Solicit and Notify}.

Omitting @var{proc} causes the loop to run continuously until the xcb
connection is disconnected.
@end deffn

@deffn {Scheme Variable} current-xcb-connection
A parameter that is dynamically bound to an event loop's xcb
connection during the dynamic extent of a call to
@code{xcb-event-loop}.
@end deffn

Two macros are provided as wrappers for @code{xcb-event-loop}:

@deffn {Scheme Syntax} with-connection xcb-conn stmt ...
Creates a thunk with body @var{stmt} ... and runs an event loop until
the thunk is completed.
@end deffn

@deffn {Scheme Syntax} loop-with-connection xcb-conn stmt ...
Creates a thunk with body @var{stmt} ... and runs an event loop until
the thunk is completed and the xcb connection is also disconnected.
@end deffn

@node Listening to the X Server
@subsection Listening to the X Server

Since the event loop is an optional feature of Guile XCB, an XCB
connection is not by default prepared for use in one. The following
procedures are available to add event loop functionality to an
existing XCB connection:

@deffn{Scheme Procedure} event-loop-prepare! xcb-conn [error-handler]
Prepares xcb connection @var{xcb-conn} for use inside of an event
loop. @var{error-handler}, if present, is a procedure that will be
called when unhandled errors are received from the X server. Otherwise
those errors will be ignored.

This procedure must be called before the xcb connection can listen for
any events, errors, or replies.
@end deffn

@deffn{Scheme Procedure} event-loop-prepared? xcb-conn
Returns @code{#t} if @var{xcb-conn} is prepared for use in an event
loop.
@end deffn

Once an XCB connection is prepared for use in an event loop, the
following procedures can be used to define its behavior when data is
received from the X server. These procedures can be called before an
event loop or inside of one. When they are called inside of an event
loop, @var{xcb-conn} is optional; omitting it will cause the value of
@code{(current-xcb-connection)} to be used instead.

@deffn{Scheme Procedure} listen! [xcb-conn] event-type tag proc [guard]

Add procedure @var{proc} to the list of procedures that may be called
when an event of type @var{event-type} is received by
@var{xcb-conn}. @var{proc} takes one argument, @var{event}, which is
an XCB structure corresponding to the event from the server.

@var{tag} is any value that can uniquely identify the procedure,
making it easier to later remove the procedure from the list. Any
procedure already associated with @var{tag} for the given
@var{event-type} will be overridden by the new one.

@var{guard}, if present, should be a predicate that takes the same
argument as @var{proc} and returns @code{#t} if @var{proc} should be
called, or @code{#f} if the event does not match some set of criteria
and @var{proc} should be skipped.

@end deffn

@deffn{Scheme Procedure} unlisten! [xcb-conn] event-type tag

Removes the event handler procedure associated with value @var{tag}
from the list of event handlers on event type @var{event-type} for xcb
connection @var{xcb-conn}.

@end deffn

@deffn{Scheme Procedure} listen-default! [xcb-conn] proc

Installs @var{proc} as the default procedure to call when an event is
not otherwise handled by @var{xcb-conn}.

@var{proc} will be called with the event as its argument; if the event
is not recognized by the connection, perhaps because it pertains to an
extension that has not been enabled, a bytevector containing the raw
binary data from the server will be passed instead.

@end deffn

@deffn{Scheme Procedure} unlisten-default! [xcb-conn]

Removes the default event handler from @var{xcb-conn}.
@end deffn

@deffn{Scheme Procedure} reply-listen! [xcb-conn] sequence-number reply-proc error-proc

When a reply or error with @var{sequence-number} is received by
@var{xcb-conn}, calls @var{reply-proc} with the reply as an argument,
or @var{error-proc} with the error as an argument, depending on the
type of result.

@end deffn

The following syntax is useful for creating a set of related,
self-contained, and self-managing event listeners:

@deffn{Scheme Syntax} create-listener (tag stop! reset! (reset-expr ...) (((event-struct event) body body* ...) ...)

Adds a set of event listeners to the current xcb connection. Each
@var{event-struct} is an XCB struct type for an event and @var{event}
is bound to the event within the accompanying expressions @var{body
body* ...}.

@var{tag} is the tag name to use in all calls to @code{listen!} and
@code{unlisten!}.

@var{stop!} is the name for a procedure that can be called anywhere in
a body expression that removes the listeners from the connection.

@var{reset!} is the name for a procedure that executes the expressions
@var{reset-expr ...} and then reinstates the listeners. It is called
once to start the listeners when the macro is first evaluated.

The macro returns @var{stop!} and @var{reset!} as two values.
@end deffn

This macro is useful, for example, when creating a text editing widget
that updates its contents on key press events and resets/stops the
listeners on window mapping/unmapping events.

@deffn{Scheme Syntax} create-listener (tag stop! (((event-struct name) body body* ...) ...)

This is shortened syntax for cases where @var{reset!} is not needed in
@code{create-listener}.

@end deffn

@node Solicit and Notify
@subsection Solicit and Notify

Most applications need more structure than what a set of isolated,
unrelated event handlers can provide. Consider, for example, a user
interface where typing a key on some widget brings up a message box
that the user must click in order to proceed. The original keypress
will launch one event handler, which then has to wait for a mouse
click.  It becomes necessary to return to the event loop, receive and
handle the mouse click event, and then resume the keypress handler
based on the mouse click handler's result.

One approach is to create a new function, called a @emph{callback},
and queue it to run when the mouse click event happens. The keypress
handler finishes, and control goes back to the event loop. When the
mouse click takes place, the callback gets invoked and finishes the
work that the keypress event started.

The callback approach is a common one and is often very
useful. However, it can sometimes lead to a very large nested mess of
callbacks within callbacks.

Thankfully, Guile includes some sophisticated control flow
maniuplation mechanisms that eliminate the need for callbacks in most
places. Guile XCB's event loop makes use of delimited continuations
and prompts to make each handler function behave as if it were running
in its own thread without any of the associated concurrency
challenges. @inforef{Prompts, Prompts, guile}.

The only caveat is that this approach only @emph{emulates}
multithreading---it is not the real thing. While an event handler is
running, no new events can be processed. Any long-running operations
that might make the application unresponsive should be handled by an
actual separate thread.

The basic mechanism is implemented by two cooperative routines,
@code{solicit} and @code{notify}.

@deffn{Scheme Procedure} solicit tag [proc]

Returns control back to the event loop until some other handler
function calls @code{notify} with the same @var{tag}; then this
@code{solicit} returns the value and the procedure continues as
normal.

If a handler has already called @code{notify} and the tag was not yet
solicited at that time, the stored value will be consumed by this call
to @code{solicit}.

If another procedure has already solicited @var{tag}, it will
never complete. Multiple @code{solicits} do not queue up.

@end deffn

@deffn{Scheme Procedure} notify tag val

Notifies the event loop of the presence of value @var{val} marked with
@var{tag} and finishes running the pending procedure that has called
@code{solicit} on @var{tag}, if it exists. Otherwise, the value will
be stored until some procedure calls @code{solicit} for @var{tag}.

@end deffn

@deffn{Scheme Procedure} make-tag datum

Creates a unique object based on @var{datum} that can be used as a tag
for calls to @code{solicit} and @code{notify}.

@end deffn

A few macros built on @code{solicit} and @code{notify} can be used for
more XCB-specific tasks:

@deffn{Scheme Procedure} delay-reply proc . args

Call XCB request procedure @var{proc} on the current xcb connection
with arguments @var{args}. Returns a tag that, when used in a call to
@code{solicit}, will yield the corresponding reply (or error) for the
request. Do not use this procedure for a request that does not receive
a reply from the server, or else the procedure that called it will
never resume.

The xcb connection is included automatically and should not be in the
list of arguments.

@end deffn

@deffn{Scheme Procedure} reply-for proc . args

Calls @code{delay-reply} on the given arguments and then immediately
solicits and returns the reply.

@end deffn

@deffn{Scheme Syntax} with-replies ((reply proc arg ...) ...) stmt stmt* ...

Calls each XCB request procedure @var{proc} with its associated
@var{arg} list as arguments. When all of the replies are received,
they are each bound to the corresponding symbol @var{reply} and used
as arguments to call a procedure with body @var{stmt stmt* ...} .

As with @code{delay-reply} and @code{reply-for}, the current xcb
connection will be used to make the reqests and an xcb connection
should not be included in the argument lists.

Returns a tag that can be used in a call to @code{solicit} to wait for
the procedure to execute and then return its result.

@end deffn

@node Built-in XCB Documentation
@section Built-in XCB Documentation

In addition to providing a specification of the X protocol, some of
the X protocol XML files also contain documentation. Guile XCB allows
the user to interactively peruse this documentation, and provides some
helpful documentation features of its own.

@menu
* XML Documentation::
* Scheme Documentation::
@end menu

@node XML Documentation
@subsection XML Documentation

Documentation of items in the X protocol XML files can have two forms:
brief, which summarizes the item in one or two sentances, and full,
which can include detailed information as well as examples and
cross-references.

@deffn {Scheme Procedure} document-full header item-type name
Display the full documentation for an XCB element @var{name} of type
@var{item-type} (@code{enum}, @code{request}, @code{reply},
etc.). @var{header} is an all lower-case symbol identifying the
extension to search for documentation (@code{xproto}, @code{bigreq},
@code{glx}, etc.). @var{header} and @var{item-type} are symbols and
@var{name} is a string.
@end deffn

@deffn {Scheme Procedure} document-brief header item-type name
Display brief documentation for an XCB element. Arguments are the same
as in @code{document-full}.
@end deffn

Unfortunately, the XCB documentation for extensions is far from
complete, though much of the core protocol is documented. The examples
provided are also written in C but translate easily enough to Scheme.

@node Scheme Documentation
@subsection Scheme Documentation

Information about various XCB requests, structures, types, enums, and
so on can be viewed by evaluating the name of the variable at the
REPL. The record type printers output, for example, a list of fields
and types for structures, and a list of keys and values for enums.

The underlying structure used to send a request to the server has the
name REQUEST-NAME-struct (@code{CreateWindow-struct},
@code{QueryExtension-struct}, etc.). Evaluating this structure at the
REPL will show the required fields for the request and their types.

A unique method is created for every single accessor and modifier in
an XCB structure in order to allow tab completion at readline-enabled
guile prompts or inside Emacs. @inforef{Using Guile in Emacs, Emacs, guile}.

@node Function Index
@unnumbered Function Index

@printindex fn

@bye
