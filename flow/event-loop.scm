(define-module (flow event-loop)
  #:use-module (ice-9 curried-definitions)
  #:use-module (ice-9 receive)
  #:use-module (ice-9 control)
  #:use-module (srfi srfi-9)
  #:use-module (ice-9 q)
  #:export (with-notifies do-event-loop))

(define-public (make-tag data) (list data))
(define-public notify-param (make-parameter #f))
(define-public (notify tag val)
  (if (notify-param)
      ((notify-param) tag val)
      (error "event-loop: Call to notify outside an event-loop")))
(define-public default-error-tag (make-parameter '(error)))
(define (default-loop-proc) (abort (make-tag 'forever)))
(define async-queue (make-parameter #f))
(define-public (enqueue-async! thunk)
  (q-push! (async-queue) thunk))

(define* (do-event-loop dispatcher finished?
                        #:optional (proc default-loop-proc)
                        #:key after on-error)
  (define (run)
    (define no-proc '(no-proc))
    (define conts (make-hash-table))
    (define early (make-hash-table))
    (define done? (make-parameter #f))
    (define finish-tag (make-tag 'finished))
    (define (notify-proc tag val)
      (cond
       ((and on-error (eq? tag (default-error-tag)))
        (abort-to-prompt (default-error-tag) val))
       ((eq? tag (default-error-tag))
        (error "event-loop: Throw to nonexistant error handler")))
      (let ((cont (hashq-ref conts tag)))
        (hashq-remove! conts tag)
        (if cont (cont val) (hashq-set! early tag val))))
    (define* (loop cont key #:optional (proc no-proc))
      (define has-proc? (and proc (not (eq? proc no-proc))))
      (define early-val (hashq-ref early key))
      (define (on-miss)
        (define (dispatch-loop)
          (let inner-loop ()
            (while (not (q-empty? (async-queue)))
              (% ((q-pop! (async-queue))) loop))
            (let ((result (dispatcher)))
              (if (or (done?) (finished?)) result (inner-loop)))))
        (hashq-set! conts key (if (not has-proc?) cont proc))
        (if has-proc? (cont #t) (dispatch-loop)))
      (define (use-early-val)
        (hashq-remove! early key)
        ((if has-proc? proc cont) early-val))
      (cond
       ((not proc) (hashq-remove! conts key) (cont))
       (early-val (% (use-early-val) loop))
       (else (% (on-miss) loop))))
    (parameterize ((notify-param notify-proc)
                   (async-queue (make-q)))
      (define final (% (let ((result (proc))) (done? #t) result) loop))
      (if (and (finished?) after) (after))
      final))
  (if on-error (call-with-prompt (default-error-tag) run on-error) (run)))

(define-syntax with-notifies
  (syntax-rules ()
    ((_ listen! ((reply arg ...) ...) stmt stmt* ...)
     ((lambda ()
        (define not-ready (make-tag 'not-ready))
        (define reply-tags (list (cons 'reply (make-tag 'reply)) ...))
        (define replies (list (cons (assq-ref reply-tags 'reply)
                                    (make-parameter not-ready)) ...))
        (define notify-tag (make-tag '(with-notifies (reply <- proc) ...)))
        (define ((update tag) val)
          (define (eval-param param) (apply param '()))
          (define reply-param (assq-ref replies tag))
          (reply-param val)
          (let  ((results (map-in-order eval-param (map-in-order cdr replies))))
            (if (not (memq not-ready results))
                (notify notify-tag
                        (apply (lambda (reply ...) stmt stmt* ...) results)))))
        (listen! (update (assq-ref reply-tags 'reply)) arg ...) ...
        notify-tag)))))
