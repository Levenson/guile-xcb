(define-module (flow event-loop)
  #:use-module (ice-9 curried-definitions)
  #:use-module (ice-9 receive)
  #:use-module (ice-9 control)
  #:use-module (srfi srfi-9)
  #:use-module (ice-9 q)
  #:export (with-notifies do-event-loop))

(define-public (make-tag data) (list data))
(define-public notify-param (make-parameter #f))
(define-public (notify tag val)
  (if (notify-param)
      ((notify-param) tag val)
      (error "event-loop: Call to notify outside an event-loop")))
(define-public default-error-tag (make-parameter '(error)))
(define async-queue (make-parameter #f))
(define-public (post-to-event-loop thunk)
  (q-push! (async-queue) thunk))
(define-public forever-tag (make-tag 'forever))

(define* (do-event-loop dispatcher finished? proc #:key after on-error)
  (define (run)
    (define conts (make-weak-key-hash-table))
    (define early (make-weak-key-hash-table))
    (define (notify-proc tag val)
      (cond
       ((and on-error (eq? tag (default-error-tag)))
        (abort-to-prompt (default-error-tag) val))
       ((eq? tag (default-error-tag))
        (error "event-loop: Throw to nonexistant error handler")))
      (let ((cont (hashq-ref conts tag)))
        (hashq-remove! conts tag)
        (if cont (cont val)
            (enq! (or (hashq-ref early tag)
                      (hashq-set! early tag (make-q)))
                  val))))
    (define* (loop cont key #:optional (proc *unspecified*))
      (define early-vals (if key (hashq-ref early key) #f))
      (define (on-miss)
        (define (dispatch-loop)
          (while (not (q-empty? (async-queue))) ((q-pop! (async-queue))))
          (let ((result (dispatcher)))
            (cond
             ((finished?) result)
             ((hashq-ref conts key) (dispatch-loop))
             (else (and=> (hashq-ref conts forever-tag)
                          (lambda (c) (% (c #t) loop)))))))
        (hashq-set! conts key (if (unspecified? proc) cont proc))
        (if (unspecified? proc) (% (dispatch-loop) loop) (% (cont #t) loop)))
      (define (use-early-val)
        (define val (deq! early-vals))
        (if (q-empty? early-vals) (hashq-remove! early key))
        (if (unspecified? proc) (% (cont val) loop) (% (proc val) loop)))
      (cond
       ((not proc) (hashq-remove! conts key) (% (cont) loop))
       (early-vals (use-early-val))
       (else (on-miss))))
    (parameterize ((notify-param notify-proc)
                   (async-queue (make-q)))
      (define final (% (let ((result (proc))) result) loop))
      (if (and (finished?) after) (after))
      final))
  (if on-error (call-with-prompt (default-error-tag) run on-error) (run)))

(define-public (notify-map reply-tags)
  (define not-ready (make-tag 'not-ready))
  (define replies
    (map (lambda (reply-tag) (cons reply-tag (make-parameter not-ready)))
         reply-tags))
  (define notify-tag (make-tag `(notify-map ,@reply-tags)))
  (define (update tag val)
    (define (eval-param param) (apply param '()))
    (define reply-param (assq-ref replies tag))
    (reply-param val)
    (let ((results (map-in-order eval-param (map-in-order cdr replies))))
      (if (not (memq not-ready results)) (notify notify-tag results))))
  (define (abort-reply reply-tag)
    (abort reply-tag (lambda (reply) (update reply-tag reply))))
  (for-each abort-reply reply-tags)
  notify-tag)
